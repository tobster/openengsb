<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!--

   Copyright 2010 OpenEngSB Division, Vienna University of Technology

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

-->
<chapter id="devQuickstart" xmlns="http://docbook.org/ns/docbook">
  <title>OpenEngSB Developer</title>
  <para>
    This chapter gives an overview how to quickly start with the OpenEngSB.
  </para>
  <section id="devQickstart.pre">
    <title>Prerequisite</title>
    <para>
      First of all the JDK6 should be installed on the system and the JAVA_HOME variable should be set. All further steps
      are described in the sub sections of this chapter.
    </para>
    <section id="devQickstart.pre.git">
      <title>Install GIT</title>
      <para>
        Further more its assumed that GIT had been installed. For GIT we recommend the latest Cygwin with the git
        packages. Please set at least the following variables:
      </para>
      <programlisting format="linespecific" language="xml"><![CDATA[git config --global user.name "Firstname Secondname"
git config --global user.email "my@email.com"
git config --global core.autcrlf input]]></programlisting>
    </section>
    <section id="devQickstart.pre.maven">
      <para>
        Finally download Apache Maven and unpack it. Add the path of the maven binary to your PATH variable. Further more
        you should add a MAVEN_OPTS variable with "-Xmx1024M -XX:MaxPermSize=512m".
      </para>
    </section>
    <section id="devQickstart.pre.smx">
      <title>Install Servicemix</title>
      <para>
        Now download Apache Servicemix in the latest version and unpack it somewhere. In the servicemix please execute the
        startup script bin/servicemix.
      </para>
    </section>
  </section>
  <section id="devQickstart.essential">
    <title>Essential Startup</title>
    <para>
      The simplest and most basic setup, required for all examples requires, first of all to checkout the openengsb
      master with the following command:
    </para>
    <programlisting format="linespecific" language="xml"><![CDATA[git clone git://github.com/openengsb/openengsb]]></programlisting>
    <para>
      Now startup servicemix with the scripts in servicemix/bin. Finally we build and deploy the OpenEngSB to servicemix.
    </para>
    <programlisting format="linespecific" language="xml"><![CDATA[cd openengsb/scripts
./quickrun.sh
]]></programlisting>
  </section>
  <section id="devQickstart.eclipse">
    <title>Import Source into Eclipse</title>
    <para>
      Eclipse had been chosen by the OpenEngSB team as their main development environment. After checkout the code the
      following command creates the required Eclipse project files:
    </para>
    <programlisting format="linespecific" language="xml"><![CDATA[mvn eclipse:eclipse]]></programlisting>
    <para>
      After this step all projects could be imported at once with the "import existing projects" command in Eclipse.
    </para>
  </section>
  <section id="devQickstart.structure">
    <title>Folder Structure</title>
    <para>
      This section describes the (sub)folder structure of the OpenEngSB. Since this project contains a huge amount of
      projects they are divided into a subfolder hierarchy. Namely there are three parts in the folder structure
      which should be explained step by step. The name of the projects is always generated by the folder
      hierarchy. For example a project nested in openengsb/features/edb/core would be named openengsb-features-edb-core.
    </para>
    <para>
      The following structure shows the core projects for the OpenEngSB. If a new project is created which es a part of
      the core of the OpenEngSB and which could not be seperated at all it would create a new subfolder in this tree.
      Because of the JBI project structure it is required that more than one project is nested in each subnode (at least
      service-unit and service-engine).
    </para>
    <programlisting format="linespecific" ><![CDATA[openengsb
openengsb/ekb
openengsb/config
openengsb/context
openengsb/package
openengsb/core
openengsb/workflow
openengsb/workflow/drools
openengsb/workflow/bpel
openengsb/testing]]></programlisting>
    <para>
      Beside of the core packages there are additional packages extending the OpenEngSB with additional features and
      therefore stored in a feature subdirectory. These projects could not exist without the OpenEngSB but the OpenEngSB
      could exist withouth them. They are designed to fulfill a specific purpose to extend the functionality of the OpenEngSB,
      but may not be interesting for most users. For this reason the folder is nested in a deeper structure.
      Features as the "edb" or "link" could be found here.
    </para>
    <programlisting format="linespecific" ><![CDATA[openengsb
openengsb/features
openengsb/features/edb
openengsb/features/link]]></programlisting>
    <para>
      The last part of the file structure contains the core packages for the OpenEngSB; its domains and connectors. As
      will be explained later in more detail the OpenEngSB integrates tool differently than a "regular" enterprise
      service bus. An enterprise service bus directly integrats tools, where the OpenEngSB adds an additional abstraction
      layer via domains. This structure is also shown in the file hierarchy. Domains are stored in a seperate subfolder,
      since they are to be seperated into subprojects in some not too far future.
    </para>
    <para>
      Each domain could be found in the openengsb/domains folder. Domains cover mostly one huge part in the engineering
      domain as SCM, notification, issues and so on. Therefore for each of these parts an additional subfolder had been
      created. The domain itself could be found in the openengsb/domains/XXX/implementation subfolder of a domain. This folder will
      always contain at leas a service-engine or a binding-unit and a service-unit. The service-engine or binding-unit
      are required to implement the domain logic at all where the service-unit is required to configure the domain. Domains
      are always configured only once in one OpenEngSB instance which explains that they are defined directly in the project.
    </para>
    <para>
      Beside the domains the real tool implementations could be found. For the notification domain useful implementations
      are, as shown, the email and jabber implementation which allows to send notifications via jabber or email. Regulary
      the service-engine is implemented, in this case directly in the root folder (.../email or .../jabber) since the service-unit
      is created at runtime for such components.
    </para>
    <para>
      The last interesting part in the domain folder is the openengsb/domains/toolAbstraction folder. This folder contains
      projects which "generally abstract" tools to a higher and better useable level and if its required to use this
      abstraction layer above several domain-tool-connectors. For example the additional required infrastructure for the
      SVN connector would not make any snese in the additional tool abstraction layer since it is only required once for
      implementing the SVN connector for the SCM domain. But compared to that maven2 could be used for more than one
      tool-domain. Maven2 could be used at least for build, test and deploy. Therefore there would be duplicated code
      to abstract the tool to the needs of the connectors. The toolAbstraction folder is the right place for additional
      abstractions required for use cases as described with the maven project.
    </para>
    <programlisting format="linespecific" ><![CDATA[openengsb
openengsb/domains
openengsb/domains/toolAbstraction
openengsb/domains/notification
openengsb/domains/notification/implementation
openengsb/domains/notification/email
openengsb/domains/notification/jabber
openengsb/domains/scm]]></programlisting>
    <para>
      Since the number of projects, required for the OpenEngSB, increases from day to day it is required to fit all projects
      into this ridgin structure to make it maintain at all.
    </para>
  </section>
  <section id="devQickstart.assembly">
    <title>Assembling the OpenEngSB</title>
  <section id="devQickstart.assembly.introduction">
    <title>Introduction</title>
    <para> This chapter gives a short overview about the assembly procedure of the OpenEngSB. Furthermore a short
      description of the structure of the assembled project is given.
  </para>
  </section>
  <section id="devQickstart.assembly.howto">
    <title>Howto assemble the OpenEngSB</title>
    <para>
      To create a distributable form of the OpenEngSB simply run the assemble.sh script in the scripts directory of the project.
      Two zip files are created in the target folder of the project root. The structure of the zips is explained in the following section.
      The zip files are called <literal>openengsb-VERSION-windows.zip</literal> and <literal>openengsb-VERSION-unix.zip.</literal> After
      unziping the assembly Servicemix can be started using the openengsb executable in the apache-servicemix-{version}/bin directory. The openengsb
      components are already included in the hotdeploy directory of Servicemix and will be started automatically on Servicemix startup.
    </para>
  </section>
  <section id="devQickstart.assembly.structure">
    <title>Structure</title>
    <para>
      <programlisting>
        openengsb-{version}
        |
        |- docs
        |    |
        |    |- html
        |    |- pdf
        |
        |- servicemix
        |    |
        |    |
        |    |- deploy (openengsb components)
        |    |- bin (executable to start servicemix - openengsb.bat or openengsb.sh)
        |
        |- README
        |- LICENSE
        |- NOTICE
      </programlisting>
    </para>
  </section>
  </section>
  <section id="git">
    <title>Git Documentation</title>
    <section>
        <title>Usage</title>
        <para>
        First of all this chapter explains only the VERY basics of git and only that parts directly relevant for the
        development of the OpenEngSB project, but not the entire idea and possibilities with git. PLEASE read a lot of
        tutorials first to get how to work with git and see this chapter more as an summary! You may also take a look
        at the {{{http://git-scm.com/documentation}Git Documentation Page}} and {{{http://progit.org/book/}Pro Git}}.
        </para>
    </section>
    <section>
      <title>Remarks</title>
      <para>
        For mac and for windows there are specific implementations of GIT. Don't use them! They do not work for what
        we like to do with them. If you're using Linux no problems at all are expected. If you're using any other platform
        use cygwin or compile the original source with ssh support! For cygwin you require the open-ssh package and the
        git and gitk packages.
      </para>
    </section>
    <section>
      <title>Github</title>
      <para>
  The OpenEngSB is developed at {{{http://github.com}github.com}}. So, please create an account and try to get
 some feeling for the platform. Please also add your real name in the admin tab and add a picture. This makes
 it easier to associate your commits with you.
      </para>
    </section>
    <section>
      <title>Starting up and configure</title>
      <para>
      Before starting to work with git some settings should be applied to git. Therefore simply execute the following
 commands one after the other in a shell.

  Of course not all of the settings are REALLY required, but others are, so please simply execute all of them!

  [[1]] git config --global user.name "FirstName LastName"

  [[2]] git config --global user.email "user@example.com"

  [[3]] git config --global color.ui "auto"

  [[4]] git config --global pack.threads "0"

  [[5]] git config --global diff.renamelimit "0"

  [[6]] git config --global core.autocrlf "input"

[]

  Additionally execute the special settings for github as could be found on github in the "Account Settings"
 tab is a point "Global git config information". Please use the two git commands described there

  [[7]] git config --global github.user YOURUSER

  [[8]] git config --global github.token YOURTOKEN

Creating and register your ssh key

 Execute the following command in shell or in cygwin:

 $ ssh-keygen

  Simply answer all questions from the application with "enter" without enter any values. Afterwards the content of the id_rsa.pub
 file from your ~/.ssh/ folder should be submitted to github ("Account Settings"/"SSH public keys").
    </para>
    </section>
    <section>
        <title>Contributor Workflow</title>
        <para>
        Contributor are all developer who like to contribute to the OpenEngSB project, but not have commit rights to the
 master. Nevertheless the same workflow is also valid for commiter with the difference that they have additional
 responsibilities.
        </para>
        <section>
            <title>Initial Setup</title>
            <para>
             * create a fork on github from the openengsb repository (http://github.com/openengsb/openengsb)

 * clone the original repo:

 $ git clone git://github.com/openengsb/openengsb (for commiter this will be git clone git@github.com:openengsb/openengsb)

 * add your fork as remote branch:

 $ git remote add USERNAME git@github.com/USERNAME/openengsb (e.g. git remote add ChristophGr git@github.com/ChristophGr/openengsb)
            </para>
        </section>
        <section>
            <title>Start some new feature</title>
            <para>
            * update remote branches

 $ git remote update -p

 * create a feature branch

 $ git checkout -b MYFEATURE origin/master

 * push the new feature to your fork:

 $ git push USERNAME MYFEATURE

 * go to the admin page of your fork and set the new branch to your default branch to MYFEATURE

 * then create a new devbranch

 $ git checkout -b devbranch MYFEATURE
            </para>
        </section>
        <section>
            <title>Develop my feature</title>
            <para>
            * and start committing to your devbranch
            </para>
        </section>
        <section>
            <title>Publish your work</title>
            <para>
 * update your local feature branch by changing from devbranch to MYFEATURE

 $ git checkout MYFEATURE

 * sync your feature with your remote repository

 $ git pull USERNAME MYFEATURE

 * rebase your dev branch with your feature branch

 $ git rebase MYFEATURE devbranch

 * go back to the feature branch

 $ git checkout MYFEATURE

 * merge your dev branch into the feature

 $ git merge devbranch

 * push the changes again

 $ git push USERNAME MYFEATURE

 * go back to your dev branch and do further development

 $ git checkout devbranch
            </para>
        </section>
        <section>
            <title>Long-Time Development Features</title>
            <para>
            If the development in the branch takes some time, it may happen, that the master-branch changes in a way that affects your featurebranch.
 To check how your branch behaves on the current master you can merge the changes into your devbranch.

 $ git checkout MYFEATURE

 $ git merge --no-commit --no-ff origin/master

  If it does not affect your development in any way, do not commit the merge, but rather undo it.

 $ git reset --hard

  If it does affect your development, you need to commit the merge. If the merge breaks something in your dev-branch, fix all
 issues before commiting the merge.  When done fixing potential issues do

 $ git commit
            </para>
        </section>
        <section>
            <title>Finish Feature</title>
            <para>
              If you think you are finished with your feature please post to the OpenEngSB developer list. A commiter will decide if he will merge your branch or give you feedback.
            </para>
        </section>
    </section>
    <section>
        <title>Commiter Workflow</title>
        <para>
        The only difference between a commiter and a contributor is that he has to watch and merge branches of
 contributors. If a commiter is happy with the work of a contributor. Comments and other discussions should be
 done on the mailing list and/or via the github review system. Commitor should always watch the branches
 and forks of contributors to review, comment and give feedback asap.

  To merge a branch of a contributor the following steps has to be done. The following preconditions are relevant:
 (1) you want to merge a feature MYFEATURE (2) from a user USERNAME. (3) Additionally we expect that the openengsb/openengsb
 repository is your origin repository.

 * first of all you have to add the user as a remote repository

 $ git remote add USERNAME git://github.com/USERNAME/openengsb

 * now update the remote repository

 $ git remote update -p

 * checkout the origin master

 $ git checkout -b master origin/master

 * merge the feature branch

 $ git merge USERNAME/MYFEATURE --no-ff

 * push the changes to the master

 $ git push origin master
        </para>
    </section>
    <section>
        <title>Additional Rules</title>
        <para>
        [[1]] (Contributor/Commiter) All development is done in forks (also of the core developers)

   [[a]] (Commiter) One exception to this rule exists: Small fixes and maintenance work which is NOT related to a new feature and does not exceed 2 commits should be rebased and merged (or cherry-picked) into the master directly.

 [[2]] (Contributor/Commiter) Rebase is NOT dead (although we use merges). NEVER EVER commit local
 merges. You still have to develop in local dev branches and rebasing them
 with the upstream branches. Only if nobody else has access to your fork you
 can be sure that nobody changed it on the way! (this workflow is explained
 in this chapter)

 [[3]] (Commiter) Merges to the master have to be done from the upstream branches not the
 local ones! This means if you want to merge the branch test from the fork
 eyeball into the master do NOT use

 $ git checkout test eyeball/test

 $ git checkout master

 $ git merge test

 BUT rather

 $ git checkout master

 $ git merge eyeball/test

 This will create much better readable merge nodes.

 [[4]] (Commiter) if merging branches from forked repositories ALWAYS use the --no-ff option
 for merges; this will always create a merge node (even if a fast-forward
 merge is possible). This is required to create a clear and consistent
 history!

 [[5]] Avoid backward merges from the master and keep feature branches small!
 This does not mean that backward merges from master are forbidden. But they should
 not be done too often, since they create a history not easy to read. Please use
 the method described on this page (with --no-ff --no-commit) to reduce the number
 of merge nodes.
MYFEATURE

 * go to the admin page of your fork and set the new branch to your default branch to MYFEATURE

 * then create a new devbranch

 $ git checkout -b devbranch MYFEATURE
            </para>
        </section>
        <section>
            <title>Develop my feature</title>
            <para>
            * and start committing to your devbranch
            </para>
        </section>
        <section>
            <title>Publish your work</title>
            <para>
 * update your local feature branch by changing from devbranch to MYFEATURE

 $ git checkout MYFEATURE

 * sync your feature with your remote repository

 $ git pull USERNAME MYFEATURE

 * rebase your dev branch with your feature branch

 $ git rebase MYFEATURE devbranch

 * go back to the feature branch

 $ git checkout MYFEATURE

 * merge your dev branch into the feature

 $ git merge devbranch

 * push the changes again

 $ git push USERNAME MYFEATURE

 * go back to your dev branch and do further development

 $ git checkout devbranch
            </para>
        </section>
        <section>
            <title>Long-Time Development Features</title>
            <para>
            If the development in the branch takes some time, it may happen, that the master-branch changes in a way that affects your featurebranch.
 To check how your branch behaves on the current master you can merge the changes into your devbranch.

 $ git checkout MYFEATURE

 $ git merge --no-commit --no-ff origin/master

  If it does not affect your development in any way, do not commit the merge, but rather undo it.

 $ git reset --hard

  If it does affect your development, you need to commit the merge. If the merge breaks something in your dev-branch, fix all
 issues before commiting the merge.  When done fixing potential issues do

 $ git commit
            </para>
        </section>
        <section>
            <title>Finish Feature</title>
            <para>
              If you think you are finished with your feature please post to the OpenEngSB developer list. A commiter will decide if he will merge your branch or give you feedback.
            </para>
        </section>

    <section>
        <title>Commiter Workflow</title>
        <para>
        The only difference between a commiter and a contributor is that he has to watch and merge branches of
 contributors. If a commiter is happy with the work of a contributor. Comments and other discussions should be
 done on the mailing list and/or via the github review system. Commitor should always watch the branches
 and forks of contributors to review, comment and give feedback asap.

  To merge a branch of a contributor the following steps has to be done. The following preconditions are relevant:
 (1) you want to merge a feature MYFEATURE (2) from a user USERNAME. (3) Additionally we expect that the openengsb/openengsb
 repository is your origin repository.

 * first of all you have to add the user as a remote repository

 $ git remote add USERNAME git://github.com/USERNAME/openengsb

 * now update the remote repository

 $ git remote update -p

 * checkout the origin master

 $ git checkout -b master origin/master

 * merge the feature branch

 $ git merge USERNAME/MYFEATURE --no-ff

 * push the changes to the master

 $ git push origin master
        </para>
    </section>
    <section>
        <title>Additional Rules</title>
        <para>
        [[1]] (Contributor/Commiter) All development is done in forks (also of the core developers)

   [[a]] (Commiter) One exception to this rule exists: Small fixes and maintenance work which is NOT related to a new feature and does not exceed 2 commits should be rebased and merged (or cherry-picked) into the master directly.

 [[2]] (Contributor/Commiter) Rebase is NOT dead (although we use merges). NEVER EVER commit local
 merges. You still have to develop in local dev branches and rebasing them
 with the upstream branches. Only if nobody else has access to your fork you
 can be sure that nobody changed it on the way! (this workflow is explained
 in this chapter)

 [[3]] (Commiter) Merges to the master have to be done from the upstream branches not the
 local ones! This means if you want to merge the branch test from the fork
 eyeball into the master do NOT use

 $ git checkout test eyeball/test

 $ git checkout master

 $ git merge test

 BUT rather

 $ git checkout master

 $ git merge eyeball/test

 This will create much better readable merge nodes.

 [[4]] (Commiter) if merging branches from forked repositories ALWAYS use the --no-ff option
 for merges; this will always create a merge node (even if a fast-forward
 merge is possible). This is required to create a clear and consistent
 history!

 [[5]] Avoid backward merges from the master and keep feature branches small!
 This does not mean that backward merges from master are forbidden. But they should
 not be done too often, since they create a history not easy to read. Please use
 the method described on this page (with --no-ff --no-commit) to reduce the number
 of merge nodes.

 [[6]] use MEANINGFUL feature branch names. Using the merge history in the master
 you can easily follow the development of features. But this requires (maybe
 long) good names! Having 7 twitter or test branches merged helps absolutely
 nothing and will only create a mess!

 [[7]] Keep your forks clean; although git can handle thousands of branches in
 thousands of forks we (as commiter) cant. Having all the forks as remote
 repositories makes it really hard for us to handle all the branches in all
 the forks. Therefore please remove ALL branches already merged or not
 required. Also remove your forked master and the already existing branches.
 You can remove your local master by changing in the admin page of your fork
 the default branch to your current branch; if master is no longer the
 default branch you can kick it. Additionally its nevertheless better to use
 the remote master instead of your forked to kick off your dev branches...
        </para>
    </section>
    </section>
    <section>
        <title>Java Coding Style</title>
        <section>
            <title>Sun Coding Guidelines</title>
            <para>
              The OpenEngSB Coding Guidelines are based upon the
 {{{http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html}Code
 Conventions for the Java Programming Language}}.  There are some additions and
 deviations for this project.
            </para>
            <section>
                <title>Line lenght</title>
                <para>
                  A line length of 80 was standard 10 years ago, but with increasing screen
size and resolution a length of 120 is more reasonable.
                </para>
            </section>
            <section>
                <title>Wrapping</title>
                <para>
                Use the auto-formatter of your IDE. Import the
  {{{http://dev.openengsb.org/resources/eclipse/formatter.xml}Eclipse Formatter file}}.
                </para>
            </section>
            <section>
                <title>Nubmer of declarations per line</title>
                <para>
                Only one declaration per line is allowed.
                </para>
            </section>
            <section>
                <title>Declaration placement</title>
                <para>
                  Declare variables where they are needed. It's easier to read and restricts the
 scope of variables.  Don't overshadow variables.
                </para>
            </section>
            <section>
                <title>Blank lines</title>
                <para>
                  The body of a method should not start with a blank line.
                </para>
            </section>
        </section>
        <section>
            <title>General</title>
            <section>
                <title>File format</title>
                <para>
                  Every Java file has to be UTF-8 encoded and has to use UNIX line endings.
 Indentations consist of four spaces, tab-stops are not allowed.
                </para>
            </section>
            <section>
                <title>Header</title>
                <para>
                  Every source file has to start with this header:

+----------------------------------------------------------------------------+
/**

   Copyright 2010 OpenEngSB Division, Vienna University of Technology

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE\-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
+----------------------------------------------------------------------------+

                </para>
            </section>
            <section>
                <title>Duplication</title>
                <para>
                  Code duplication has to be avoided at all costs.
                </para>
            </section>
            <section>
            <title>Use guards</title>
            <para>
              Guards are a possibility to reduce the amount of nesting.  Heavily nested
 code is much harder to read.
 Bad:

+----------------------------------------------------------------------------+
  public void foo() {
      if (conditionA) {
          if (conditionB) {
              if (conditionC) {
                  // do some work
              }
          } else {
              throw new MyException();
          }
      }
  }
+----------------------------------------------------------------------------+

 Good:

+----------------------------------+
  public void foo() {
    if (!conditionA) {
        return;
    }

    if (!conditionB) {
        throw new MyException();
    }

    if (!conditionC) {
        return;
    }

    // do some work
  }
+----------------------------------+

            </para>
            </section>
            <section>
                <title>Keep methods short</title>
                <para>
                  Methods longer than 40 lines are candidates for refactoring. A method should only
 do one thing and has to be easily understandable. The number of arguments should be
 minimized.  A method should only be at a single level of abstraction.
                </para>
            </section>
            <section>
                <title>Use enums</title>
                <para>
                  Prefer typesafe enumerations over integer constants.
                </para>
            </section>
            <section>
                <title>Avoid use of static members</title>
                <para>  Static members are a sign of a design error because they are like global variables.
  It's fine if you declare a constant as final abstract of course.
                </para>
            </section>
            <section>
                <title>Use fully qualified imports</title>
                <para>
                  Don't import org.example.package.*, instead import the needed classes.
                </para>
            </section>
            <section>
                <title>Never declare implementation types</title>
                <para>
                Use interfaces or the abstract base class instead of concrete implementation
 classes where possible.  Don't write:

+----------------------------------------------------+
 ArrayListString names = new ArrayListString();
+----------------------------------------------------+

 Instead use the interface name:

+----------------------------------------------------+
 ListString names = new ArrayListString();
+----------------------------------------------------+

 This is especially important in method signatures.
                </para>
            </section>
            <section>
                <title>SerialVersionUID</title>
                <para>
                  Don't declare serialVersionUID just because your IDE tells you. Have a good reason
 why you need it.  This can cause bugs that are hard to detect.
                </para>
            </section>
            <section>
                <title>Restrict scope of suppressed warnings</title>
                <para>
                 If you have to suppress a warning make sure you give it the smallest possible scope.
This means you should never annotate a whole class with @SuppressWarnings. A method may
be acceptable but you should try to annotate the problematic statements instead.
                </para>
            </section>
            <section>
                <title>Use String.format()</title>
                <para>
                Use String.format() instead of long concatenation chains which are hard to read.
                </para>
            </section>
            <section>
                <title>Array declaration style</title>
                <para>
                  Always use

+---------------------------+
 Type[] arrayName;
+---------------------------+

 instead of the C-like

+---------------------------+
 Type arrayName[];
+---------------------------+
                </para>
            </section>
            <section>
                <title>Comments</title>
                <para>
                  Don't make funny comments, be professional. All comments have to be in English.
 Comment what methods do, not how they do it. Do not comment what is already stated
 in code.
                </para>
            </section>
        </section>
        <section>
            <title>Naming</title>
            <section>
                <title>Interfaces</title>
                <para>
                  Interfaces are not marked by starting their names with I.  This exposes
 more information than necessary and is not Java-like.
                </para>
            </section>
            <section>
                <title>Don't abbreviate</title>
                <para>
                  Do not use abbreviations if it's not a project wide standard. Long method names
 are preferable to inconsistency.  With automatic code completion this isn't a problem
 anyway.
                </para>
            </section>
        </section>
        <section>
            <title>No clutter</title>
            <para>
             * Exception/Log Messages have to be concise. Don't end messages with "...".

 * Don't overuse FINAL, use it where you have a good reason something has to be
   final.  Although it doesn't hurt to declare everything as final it clutters the
   code.

 * Don't use history tables in source files.  Use the SCM system if you are
   interested in the changes of a file.

 * Don't use the JavaDoc author tag.  Also use the SCM system.

 * Don't declare unnecessary constructors, especially the empty default constructor.

 * Don't make implicit calls explicitly, i.e. calling super(); in every constructor.

 * Don't specify modifiers that are implicit, i.e. don't make methods in interfaces
   public abstract.

 * Don't initialize fields with null, they are automatically initialized with null.

 * Don't use banners in comments.

 * Don't use closing brace comments, i.e. } // end if, they are a sign of too long
   methods.

 * Don't comment out code and commit it. This confuses programmers why it is there.
   Simply delete it, it's still present in the SCM history.
            </para>
        </section>
        <section>
            <title>Exception Handling</title>
            <para>
             * Don't log and throw. Either a exception should be logged or thrown to be processed
   at a more appropriate place.

 * Don't swallow exceptions silently. If you have to do it, you have to make a comment
   stating the reason.

 * Use runtime exceptions where possible.

 * Wrap exceptions in a RuntimeException if you don't want to specify the Exception in
   your method signature and you can't handle it.

 * Write meaningful exception message.

            </para>
        </section>
        <section>
            <title>Tests</title>
            <section>
                <title>General</title>
                <para>
                 * Make use of JUnit 4 features, e.g. @Test(expected = SomeException.class)

 * Tests should not output anything. They have to be automatically verified.

 * Don't catch exceptions just to fail manually. Declare the method to throw the exception.

 * Install a shutdown hook for test data files. This assures that they will be deleted and the
   project remains in a clean state.

 * Use {{{http://code.google.com/p/mockito/}Mockito}} for mocking.

 * Tests should have descriptive method names. It should be deducible what will be tested.
   Bad: testFoo(). Good: invalidInMessageShouldReturnErrorResponse() or
   findByName_NonexistingName_returnsNull().
                </para>
            </section>
            <section>
                <title>Naming Scheme</title>
                <para>
                  The maven profiles for running the tests are configured to filter based on the
naming of the test class. The package layout is just a further convenience for the
developer for running the tests manually.

 * Unit Tests test one class/method/feature in isolation from their dependencies by
   using test doubles as replacement. They should be fast and need no special environment
   setup for execution.

  * Filenames end with Test.java

  * Located in the normal package structure,
    i.e. \outer.project.package\.\inner.project.package\

 * Integration Tests combine individual software modules to test their interaction with
   each other. They do not need a special environment setup for execution.

  * Filenames end with IT.java

  * Located in \outer.project.package\.it.\inner.project.package\

 * User Tests need a special execution environment and thus are not run
   automatically during any maven phase.

  * Filenames end with UT.java

  * Located in \outer.project.package\.ut.\inner.project.package\
                </para>
            </section>
        </section>
        <section>
            <title>XML Formatting</title>
            <section>
                <title>File Format</title>
                <para>
                  Every XML file has to be UTF-8 encoded and has to use UNIX line endings.
Indentations consist of TWO spaces, tabstops are not allowed. The line length
shouldn't exceed 120 characters.
                </para>
            </section>
            <section>
                <title>Indent DTD properly</title>
                <para>
                  There should be a new line for every namespace:

+------------------------------------------------------------------------------------------------------------------+
beans xmlns="http://www.springframework.org/schema/beans" xmlns:build="urn:openengsb:build"
  xmlns:mvn="http://openengsb.org/connector/mvn/1.0"
  xmlns:xsi="http://http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
    http://servicemix.apache.org/bean/1.0 http://servicemix.apache.org/schema/servicemix-bean-3.2.3.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
+------------------------------------------------------------------------------------------------------------------+

                </para>
            </section>
            <section>
            <title>Eclispe Settings</title>
            <para>
            If you use Eclipse please choose these settings for your OpenEngSB workspace:
<mediaobject>
        <imageobject>
          <imagedata id="form" fileref="graphics/eclipse-xml-settings.png"
            format="png" />
        </imageobject>
        <caption>Eclipse XML Settigns</caption>
      </mediaobject>
            </para>
            </section>
            <section>
                <title>Recommended Readings</title>
                <para>
                 * Clean Code, Robert C. Martin, 2008

 * Effective Java Second Edition, Joshua Bloch, 2008

 * {{{http://www.garshol.priv.no/blog/105.html} 7 tips on writing clean code}}
                </para>
            </section>
        </section>

    </section>
</chapter>
